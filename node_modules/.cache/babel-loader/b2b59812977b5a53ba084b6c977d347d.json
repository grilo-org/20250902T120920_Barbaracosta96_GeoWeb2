{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */function (_super) {\n  __extends(PDFParser, _super);\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n  PDFParser.prototype.parseDocument = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFParser', 'parseDocument');\n            }\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n          case 1:\n            if (!!this.bytes.done()) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.parseDocumentSection()];\n          case 2:\n            _a.sent();\n            offset = this.bytes.offset();\n            if (offset === prevOffset) {\n              throw new StalledParserError(this.bytes.position());\n            }\n            prevOffset = offset;\n            return [3 /*break*/, 1];\n          case 3:\n            this.maybeRecoverRoot();\n            if (this.context.lookup(PDFRef.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef.of(0));\n            }\n            return [2 /*return*/, this.context];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function isValidCatalog(obj) {\n      return obj instanceof PDFDict && obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n    };\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n          ref = _a[0],\n          object = _a[1];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n    throw new MissingPDFHeaderError(this.bytes.position());\n  };\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n    return PDFRef.of(objectNumber, generationNumber);\n  };\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n  PDFParser.prototype.parseIndirectObject = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments();\n            // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n            this.matchKeyword(Keywords.endobj);\n            if (!(object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n            return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n              PDFXRefStreamParser.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, ref];\n        }\n      });\n    });\n  };\n  // TODO: Improve and clean this up\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords.endobj.length;\n    var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n          case 1:\n            if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.parseIndirectObject()];\n          case 3:\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_1 = _a.sent();\n            // TODO: Add tracing/logging mechanism to track when this happens!\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3 /*break*/, 5];\n          case 5:\n            this.skipWhitespaceAndComments();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n            return [4 /*yield*/, waitForTick()];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection.createEmpty();\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        var ref = PDFRef.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n    return xref;\n  };\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID\n    };\n  };\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  };\n  PDFParser.prototype.parseDocumentSection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.parseIndirectObjects()];\n          case 1:\n            _a.sent();\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  };\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n  return PDFParser;\n}(PDFObjectParser);\nexport default PDFParser;","map":{"version":3,"mappings":"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","names":["PDFCrossRefSection","PDFHeader","PDFTrailer","MissingKeywordError","MissingPDFHeaderError","PDFInvalidObjectParsingError","ReparseError","StalledParserError","PDFDict","PDFInvalidObject","PDFName","PDFRawStream","PDFRef","ByteStream","PDFObjectParser","PDFObjectStreamParser","PDFXRefStreamParser","PDFContext","CharCodes","Keywords","IsDigit","waitForTick","__extends","pdfBytes","objectsPerTick","throwOnInvalidObject","capNumbers","_super","of","create","_this","parsedObjects","PDFParser","alreadyParsed","context","header","parseHeader","bytes","done","parseDocumentSection","_a","offset","prevOffset","position","maybeRecoverRoot","lookup","console","warn","delete","isValidCatalog","obj","catalog","trailerInfo","Root","indirectObjects","enumerateIndirectObjects","idx","len","length","ref","object","matchKeyword","major","parseRawInt","assertNext","Period","minor","forVersion","skipBinaryHeaderComment","next","skipWhitespaceAndComments","objectNumber","generationNumber","initialOffset","parseIndirectObjectHeader","e","moveTo","parseObject","endobj","dict","forStream","shouldWaitForTick","parseIntoContext","assign","startPos","msg","JSON","stringify","Error","start","failed","end","slice","peek","parseIndirectObject","tryToParseInvalidIndirectObject","skipJibberish","xref","createEmpty","firstInt","secondInt","byte","n","f","addEntry","addDeletedEntry","trailer","parseDict","get","Encrypt","Info","ID","startxref","skipWhitespace","eof","forLastCrossRefSectionOffset","parseIndirectObjects","maybeParseCrossRefSection","maybeParseTrailerDict","maybeParseTrailer","isAlphaNumeric","Space","Tilde","matchIndirectObjectHeader"],"sourceRoot":"","sources":["../../../src/core/parser/PDFParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}