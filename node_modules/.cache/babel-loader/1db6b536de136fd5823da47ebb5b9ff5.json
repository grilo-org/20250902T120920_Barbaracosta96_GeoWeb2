{"ast":null,"code":"import { NextByteAssertionError } from \"../errors\";\nimport { decodePDFRawStream } from \"../streams/decode\";\nimport CharCodes from \"../syntax/CharCodes\";\n// TODO: See how line/col tracking affects performance\nvar ByteStream = /** @class */function () {\n  function ByteStream(bytes) {\n    this.idx = 0;\n    this.line = 0;\n    this.column = 0;\n    this.bytes = bytes;\n    this.length = this.bytes.length;\n  }\n  ByteStream.prototype.moveTo = function (offset) {\n    this.idx = offset;\n  };\n  ByteStream.prototype.next = function () {\n    var byte = this.bytes[this.idx++];\n    if (byte === CharCodes.Newline) {\n      this.line += 1;\n      this.column = 0;\n    } else {\n      this.column += 1;\n    }\n    return byte;\n  };\n  ByteStream.prototype.assertNext = function (expected) {\n    if (this.peek() !== expected) {\n      throw new NextByteAssertionError(this.position(), expected, this.peek());\n    }\n    return this.next();\n  };\n  ByteStream.prototype.peek = function () {\n    return this.bytes[this.idx];\n  };\n  ByteStream.prototype.peekAhead = function (steps) {\n    return this.bytes[this.idx + steps];\n  };\n  ByteStream.prototype.peekAt = function (offset) {\n    return this.bytes[offset];\n  };\n  ByteStream.prototype.done = function () {\n    return this.idx >= this.length;\n  };\n  ByteStream.prototype.offset = function () {\n    return this.idx;\n  };\n  ByteStream.prototype.slice = function (start, end) {\n    return this.bytes.slice(start, end);\n  };\n  ByteStream.prototype.position = function () {\n    return {\n      line: this.line,\n      column: this.column,\n      offset: this.idx\n    };\n  };\n  ByteStream.of = function (bytes) {\n    return new ByteStream(bytes);\n  };\n  ByteStream.fromPDFRawStream = function (rawStream) {\n    return ByteStream.of(decodePDFRawStream(rawStream).decode());\n  };\n  return ByteStream;\n}();\nexport default ByteStream;","map":{"version":3,"mappings":"AAAA,SAASA,sBAAsB,QAAE;AAEjC,SAASC,kBAAkB,QAAE;AAC7B,OAAOC,SAAS;AAEhB;AACA;EAaE,oBAAYC,KAAiB;IAJrB,QAAG,GAAG,CAAC;IACP,SAAI,GAAG,CAAC;IACR,WAAM,GAAG,CAAC;IAGhB,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,MAAM,GAAG,IAAI,CAACD,KAAK,CAACC,MAAM;EACjC;EAEAC,2BAAM,GAAN,UAAOC,MAAc;IACnB,IAAI,CAACC,GAAG,GAAGD,MAAM;EACnB,CAAC;EAEDD,yBAAI,GAAJ;IACE,IAAMG,IAAI,GAAG,IAAI,CAACL,KAAK,CAAC,IAAI,CAACI,GAAG,EAAE,CAAC;IACnC,IAAIC,IAAI,KAAKN,SAAS,CAACO,OAAO,EAAE;MAC9B,IAAI,CAACC,IAAI,IAAI,CAAC;MACd,IAAI,CAACC,MAAM,GAAG,CAAC;KAChB,MAAM;MACL,IAAI,CAACA,MAAM,IAAI,CAAC;;IAElB,OAAOH,IAAI;EACb,CAAC;EAEDH,+BAAU,GAAV,UAAWO,QAAgB;IACzB,IAAI,IAAI,CAACC,IAAI,EAAE,KAAKD,QAAQ,EAAE;MAC5B,MAAM,IAAIZ,sBAAsB,CAAC,IAAI,CAACc,QAAQ,EAAE,EAAEF,QAAQ,EAAE,IAAI,CAACC,IAAI,EAAE,CAAC;;IAE1E,OAAO,IAAI,CAACE,IAAI,EAAE;EACpB,CAAC;EAEDV,yBAAI,GAAJ;IACE,OAAO,IAAI,CAACF,KAAK,CAAC,IAAI,CAACI,GAAG,CAAC;EAC7B,CAAC;EAEDF,8BAAS,GAAT,UAAUW,KAAa;IACrB,OAAO,IAAI,CAACb,KAAK,CAAC,IAAI,CAACI,GAAG,GAAGS,KAAK,CAAC;EACrC,CAAC;EAEDX,2BAAM,GAAN,UAAOC,MAAc;IACnB,OAAO,IAAI,CAACH,KAAK,CAACG,MAAM,CAAC;EAC3B,CAAC;EAEDD,yBAAI,GAAJ;IACE,OAAO,IAAI,CAACE,GAAG,IAAI,IAAI,CAACH,MAAM;EAChC,CAAC;EAEDC,2BAAM,GAAN;IACE,OAAO,IAAI,CAACE,GAAG;EACjB,CAAC;EAEDF,0BAAK,GAAL,UAAMY,KAAa,EAAEC,GAAW;IAC9B,OAAO,IAAI,CAACf,KAAK,CAACgB,KAAK,CAACF,KAAK,EAAEC,GAAG,CAAC;EACrC,CAAC;EAEDb,6BAAQ,GAAR;IACE,OAAO;MAAEK,IAAI,EAAE,IAAI,CAACA,IAAI;MAAEC,MAAM,EAAE,IAAI,CAACA,MAAM;MAAEL,MAAM,EAAE,IAAI,CAACC;IAAG,CAAE;EACnE,CAAC;EAjEMF,aAAE,GAAG,UAACF,KAAiB;IAAK,WAAIE,UAAU,CAACF,KAAK,CAAC;EAArB,CAAqB;EAEjDE,2BAAgB,GAAG,UAACe,SAAuB;IAChD,iBAAU,CAACC,EAAE,CAACpB,kBAAkB,CAACmB,SAAS,CAAC,CAACE,MAAM,EAAE,CAAC;EAArD,CAAqD;EA+DzD,iBAAC;CAAA,EAnED;AAqEA,eAAejB,UAAU","names":["NextByteAssertionError","decodePDFRawStream","CharCodes","bytes","length","ByteStream","offset","idx","byte","Newline","line","column","expected","peek","position","next","steps","start","end","slice","rawStream","of","decode"],"sourceRoot":"","sources":["../../../src/core/parser/ByteStream.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}