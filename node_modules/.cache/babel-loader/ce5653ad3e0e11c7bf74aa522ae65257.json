{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */function (_super) {\n  __extends(PDFObjectParser, _super);\n  function PDFObjectParser(byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, byteStream, capNumbers) || this;\n    _this.context = context;\n    return _this;\n  }\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  PDFObjectParser.prototype.parseObject = function () {\n    this.skipWhitespaceAndComments();\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n    var byte = this.bytes.peek();\n    if (byte === CharCodes.LessThan && this.bytes.peekAhead(1) === CharCodes.LessThan) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  };\n  PDFObjectParser.prototype.parseNumberOrRef = function () {\n    var firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n    var lookaheadStart = this.bytes.offset();\n    if (IsDigit[this.bytes.peek()]) {\n      var secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  };\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  PDFObjectParser.prototype.parseHexString = function () {\n    var value = '';\n    this.bytes.assertNext(CharCodes.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    return PDFHexString.of(value);\n  };\n  PDFObjectParser.prototype.parseString = function () {\n    var nestingLvl = 0;\n    var isEscaped = false;\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.next();\n      value += charFromCode(byte);\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      }\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  };\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  PDFObjectParser.prototype.parseName = function () {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n    var name = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n    return PDFName.of(name);\n  };\n  PDFObjectParser.prototype.parseArray = function () {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n    var pdfArray = PDFArray.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      var element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  };\n  PDFObjectParser.prototype.parseDict = function () {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n    var dict = new Map();\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan && this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n      var key = this.parseName();\n      var value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    var Type = dict.get(PDFName.of('Type'));\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  };\n  PDFObjectParser.prototype.parseDictOrStream = function () {\n    var startPos = this.bytes.position();\n    var dict = this.parseDict();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {\n      return dict;\n    }\n    var start = this.bytes.offset();\n    var end;\n    var Length = dict.get(PDFName.of('Length'));\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n    var contents = this.bytes.slice(start, end);\n    return PDFRawStream.of(dict, contents);\n  };\n  PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n    // Move to end of stream, while handling nested streams\n    var nestingLvl = 1;\n    var end = this.bytes.offset();\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n      if (nestingLvl === 0) break;\n    }\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n    return end;\n  };\n  PDFObjectParser.forBytes = function (bytes, context, capNumbers) {\n    return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n  };\n  PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    return new PDFObjectParser(byteStream, context, capNumbers);\n  };\n  return PDFObjectParser;\n}(BaseParser);\nexport default PDFObjectParser;","map":{"version":3,"mappings":"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","names":["PDFObjectParsingError","PDFStreamParsingError","UnbalancedParenthesisError","PDFArray","PDFBool","PDFDict","PDFHexString","PDFName","PDFNull","PDFNumber","PDFRawStream","PDFRef","PDFString","BaseParser","ByteStream","PDFCatalog","PDFPageLeaf","PDFPageTree","CharCodes","IsDelimiter","Keywords","IsDigit","IsNumeric","IsWhitespace","charFromCode","__extends","byteStream","context","capNumbers","_super","_this","PDFObjectParser","skipWhitespaceAndComments","matchKeyword","true","True","false","False","null","byte","bytes","peek","LessThan","peekAhead","parseDictOrStream","parseHexString","LeftParen","parseString","ForwardSlash","parseName","LeftSquareBracket","parseArray","parseNumberOrRef","position","firstNum","parseRawNumber","lookaheadStart","offset","secondNum","R","assertNext","of","moveTo","value","done","GreaterThan","next","nestingLvl","isEscaped","RightParen","BackSlash","substring","length","name","pdfArray","withContext","RightSquareBracket","element","parseObject","push","dict","Map","key","set","Type","get","fromMapWithContext","startPos","parseDict","streamEOF1","streamEOF2","streamEOF3","streamEOF4","stream","start","end","Length","asNumber","endstream","findEndOfStreamFallback","contents","slice","EOF1endstream","EOF2endstream","EOF3endstream"],"sourceRoot":"","sources":["../../../src/core/parser/PDFObjectParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}