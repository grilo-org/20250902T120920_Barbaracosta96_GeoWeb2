{"ast":null,"code":"import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline,\n  CarriageReturn = CharCodes.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */function () {\n  function BaseParser(bytes, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    this.bytes = bytes;\n    this.capNumbers = capNumbers;\n  }\n  BaseParser.prototype.parseRawInt = function () {\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n    return numberValue;\n  };\n  // TODO: Maybe handle exponential format?\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  BaseParser.prototype.parseRawNumber = function () {\n    var value = '';\n    // Parse integer-part, the leading (+ | - | . | 0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsNumeric[byte]) break;\n      value += charFromCode(this.bytes.next());\n      if (byte === CharCodes.Period) break;\n    }\n    // Parse decimal-part, the trailing (0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n    if (numberValue > Number.MAX_SAFE_INTEGER) {\n      if (this.capNumbers) {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n        console.warn(msg);\n        return Number.MAX_SAFE_INTEGER;\n      } else {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n        console.warn(msg);\n      }\n    }\n    return numberValue;\n  };\n  BaseParser.prototype.skipWhitespace = function () {\n    while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipLine = function () {\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return;\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipComment = function () {\n    if (this.bytes.peek() !== CharCodes.Percent) return false;\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return true;\n      this.bytes.next();\n    }\n    return true;\n  };\n  BaseParser.prototype.skipWhitespaceAndComments = function () {\n    this.skipWhitespace();\n    while (this.skipComment()) {\n      this.skipWhitespace();\n    }\n  };\n  BaseParser.prototype.matchKeyword = function (keyword) {\n    var initialOffset = this.bytes.offset();\n    for (var idx = 0, len = keyword.length; idx < len; idx++) {\n      if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n        this.bytes.moveTo(initialOffset);\n        return false;\n      }\n    }\n    return true;\n  };\n  return BaseParser;\n}();\nexport default BaseParser;","map":{"version":3,"mappings":"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","names":["NumberParsingError","CharCodes","IsDigit","IsNumeric","IsWhitespace","charFromCode","CarriageReturn","bytes","capNumbers","BaseParser","value","done","byte","peek","next","numberValue","Number","isFinite","position","Period","MAX_SAFE_INTEGER","msg","console","warn","Newline","Percent","skipWhitespace","skipComment","keyword","initialOffset","offset","idx","len","length","moveTo"],"sourceRoot":"","sources":["../../../src/core/parser/BaseParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}